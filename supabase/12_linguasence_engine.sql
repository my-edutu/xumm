-- XUM Linguasense Engine v2 Implementation
-- This migration expands the lexicon system into a full data synthesis engine.

-- 1. Linguasense Projects (Campaigns)
CREATE TABLE IF NOT EXISTS public.linguasence_projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.users(id), -- Owner (Company)
    title TEXT NOT NULL,
    description TEXT,
    target_language_code TEXT NOT NULL,
    data_type TEXT CHECK (data_type IN ('text', 'voice', 'both', 'image')),
    required_samples INTEGER DEFAULT 1000,
    reward_per_sample DECIMAL(10,4) NOT NULL,
    status TEXT DEFAULT 'active', -- 'active', 'paused', 'completed'
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 2. Grounding Tasks (The Prompts)
-- These can be auto-generated by an LLM or uploaded by a company.
CREATE TABLE IF NOT EXISTS public.linguasence_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES public.linguasence_projects(id) ON DELETE CASCADE,
    prompt_text TEXT NOT NULL, -- e.g., "What is the local slang for 'Expensive' in Lagos?"
    context_metadata JSONB, -- Context for the LLM or user
    difficulty_score INTEGER DEFAULT 1,
    is_llm_generated BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 3. Linguasense Responses (The Grounding)
CREATE TABLE IF NOT EXISTS public.linguasence_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES public.linguasence_tasks(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.users(id),
    text_input TEXT,
    audio_url TEXT,
    metadata JSONB, -- { "location": "...", "device": "..." }
    consensus_status TEXT DEFAULT 'pending', -- 'pending', 'verified', 'disputed'
    consensus_score DECIMAL(3,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 4. Consensus & Validation Layer
CREATE TABLE IF NOT EXISTS public.linguasence_validations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    response_id UUID REFERENCES public.linguasence_responses(id) ON DELETE CASCADE,
    validator_id UUID REFERENCES public.users(id),
    is_valid BOOLEAN NOT NULL,
    feedback TEXT,
    agreement_score DECIMAL(3,2), -- How much it aligns with previous users
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 5. Company API Infrastructure (Commercialization)
CREATE TABLE IF NOT EXISTS public.company_api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.users(id),
    name TEXT NOT NULL,
    api_key_hash TEXT UNIQUE NOT NULL,
    prefix TEXT NOT NULL, -- First 7-8 chars for identification
    scopes TEXT[] DEFAULT '{ "read:datasets", "write:tasks" }',
    last_used TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 6. Usage Metering
CREATE TABLE IF NOT EXISTS public.api_usage_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    key_id UUID REFERENCES public.company_api_keys(id),
    endpoint TEXT NOT NULL,
    status_code INTEGER,
    response_time_ms INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- RLS Policies
ALTER TABLE public.linguasence_projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linguasence_tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linguasence_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linguasence_validations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.company_api_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_usage_logs ENABLE ROW LEVEL SECURITY;

-- Project visibility
CREATE POLICY "Public read active projects" ON public.linguasence_projects 
    FOR SELECT USING (status = 'active');

-- Responses (Users see their own, admins see all)
CREATE POLICY "Users view own responses" ON public.linguasence_responses
    FOR SELECT USING (auth.uid() = user_id);

-- API Keys (Only owners see their keys)
CREATE POLICY "Companies view own API keys" ON public.company_api_keys
    FOR SELECT USING (auth.uid() = company_id);

-- Functions

-- 1. Advanced Weighted Consensus Calculation
-- Weights votes based on the validator's trust_score
CREATE OR REPLACE FUNCTION public.calculate_weighted_consensus(resp_id UUID)
RETURNS VOID AS $$
DECLARE
    weighted_pos_sum DECIMAL(10,2) := 0;
    total_weight_sum DECIMAL(10,2) := 0;
    v_record RECORD;
BEGIN
    -- Loop through all validations for this response
    FOR v_record IN 
        SELECT v.is_valid, u.trust_score 
        FROM public.linguasence_validations v
        JOIN public.users u ON v.validator_id = u.id
        WHERE v.response_id = resp_id
    LOOP
        weighted_pos_sum := weighted_pos_sum + (CASE WHEN v_record.is_valid THEN v_record.trust_score ELSE 0 END);
        total_weight_sum := total_weight_sum + v_record.trust_score;
    END LOOP;

    -- Update response with weighted score
    IF total_weight_sum > 0 THEN
        UPDATE public.linguasence_responses
        SET consensus_score = weighted_pos_sum / total_weight_sum,
            consensus_status = CASE 
                WHEN (weighted_pos_sum / total_weight_sum) >= 0.85 THEN 'verified'
                WHEN (weighted_pos_sum / total_weight_sum) <= 0.15 THEN 'rejected'
                WHEN (weighted_pos_sum / total_weight_sum) BETWEEN 0.35 AND 0.65 THEN 'disputed'
                ELSE 'pending'
            END
        WHERE id = resp_id;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. API Key Verification Function (Simulated Hash Check)
-- In production, this would use a more secure pgcrypto check
CREATE OR REPLACE FUNCTION public.verify_company_api_key(p_prefix TEXT, p_provided_key TEXT)
RETURNS UUID AS $$
DECLARE
    v_company_id UUID;
BEGIN
    SELECT company_id INTO v_company_id
    FROM public.company_api_keys
    WHERE prefix = p_prefix 
      AND api_key_hash = crypt(p_provided_key, api_key_hash)
      AND is_active = true;

    IF v_company_id IS NOT NULL THEN
        UPDATE public.company_api_keys 
        SET last_used = now() 
        WHERE prefix = p_prefix;
        RETURN v_company_id;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Auto-Trigger for Consensus
CREATE OR REPLACE FUNCTION public.trg_on_validation_added()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM public.calculate_weighted_consensus(NEW.response_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_linguasence_validation_added
    AFTER INSERT ON public.linguasence_validations
    FOR EACH ROW EXECUTE FUNCTION public.trg_on_validation_added();
